#### [第一题](https://leetcode.cn/problems/apply-operations-to-make-sum-of-array-greater-than-or-equal-to-k/)
##### 法一：枚举
时间复杂度：O(nmin(n,262))//n为字符串s的长度。
```
class Solution {
public:
    int maximumLengthSubstring(string s) {
        int res=0;
        for(int i=0;i<s.size();i++){
            int cnt[26]{};
            for(int j=i;j<s.size();j++){
                int b=s[j]-'a';
                cnt[b]++;
                if(cnt[b]>2){
                    break;
                }
                res=max(res,j-i+1); 
            }
        }
        return res;
    }
};
```
##### 法二：滑动窗口
时间复杂度：O(n+∣Σ∣)，其中 n为 s 的长度，∣Σ∣ 为字符集合的大小，本题字符均为小写字母，所以 ∣Σ∣=26。虽然写了个二重循环，但是内层循环中对 left 加一的总执行次数不会超过 n次。
空间复杂度：O(∣Σ∣)。
```
class Solution {
public:
    int maximumLengthSubstring(string s) {
        int res=0,left=0,cnt[26]{};
        for(int i=0;i<s.size();i++){
            int b=s[i]-'a';
            cnt[b]++;
            while(cnt[b]>2) cnt[s[left++]-'a']--;
            res=max(res,i-left+1);
        }
        return res;
    }
};
```
#### [第二题](https://leetcode.cn/problems/apply-operations-to-make-sum-of-array-greater-than-or-equal-to-k/)
##### 法一：贪心 + 枚举
设当前数组最大值为 m，对它做加一操作更好（因为复制最大值最优）。
如果先复制m，再加一，那么元素和增加了m+1。
如果先加一，再复制m+1，那么元素和增加了m+2。
所以，先加一再复制更优。
所以，加一操作都应当在复制操作之前。
```
class Solution {
public:
    int minOperations(int k) {
        int res=INT_MAX;
        for(int m=1;m<=k;m++){
            res=min(res,m-1+(k-1)/m);
        }
        return res;
    }
};
```
复杂度分析
时间复杂度：O(k)。
空间复杂度：O(1)。
##### 方法二：数学
由基本不等式，或者对勾函数性质可知，那么当 m取(int)sqrt(k-1)-1或者(int)sqrt(k-1)+1时我们可以得到最小值。
为防止m=0，可以和1取最大值（或者特判）。
```
class Solution {
public:
    int minOperations(int k) {
        int m=max((int)sqrt(k-1),1);
        return min(m-1+(k-1)/m,m+(k-1)/(m+1));
    }
};
```
复杂度分析
时间复杂度：O(1)。
空间复杂度：O(1)。

