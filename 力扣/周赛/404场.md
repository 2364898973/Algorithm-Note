# [第一题](https://leetcode.cn/problems/maximum-height-of-a-triangle/description/)

## 方法一：枚举

```
class Solution {
public:
    int maxHeightOfTriangle(int red, int blue) {
        auto f=[&](int a,int b){
            int i=1;
            while(1){
                if(i%2){
                    if(a>=i) a-=i;
                    else break;
                } else{
                    if(b>=i) b-=i;
                    else break;
                }
                i++;
            }
            return i-1;
        };
        return max(f(red,blue),f(blue,red));
    }
};
```

复杂度分析
* 时间复杂度：O(min(sqrt(red),sqrt(blue))。
* 空间复杂度：O(1)。

## 方法二：数学(等差数列)

核心思路:

奇数行放红球，偶数行放蓝球；或者奇数行放蓝球，偶数行放红球。两种情况取最大值。

1.奇数行

设奇数行有 k 行，那么需要

$$1+3+5+⋯+(2k−1)=(k)^2$$
 
个球。

假设有 n 个球放奇数行，那么有

$$n≥(k)^2$$
 
解得

$$k≤\sqrt(n)$$
​
2.偶数行

设偶数行有 k 行，那么需要

$$2+4+6+⋯+2k=(k)^2+k$$

个球。

假设有 n 个球放奇数行，那么有

$$n≥(k)^2+k$$

解得

$$k≤(\sqrt(4*n+1)-1)/2$$

设有 odd 个奇数行，even 个偶数行，那么行数为

* 2*even+1,odd>even
* 2*odd,odd≤even

```
class Solution {
public:
    int maxHeightOfTriangle(int red, int blue) {
        auto f=[&](int a,int b){
            int odd=sqrt(a);
            int even=(sqrt(4*b+1)-1)/2;
            return odd>even?2*even+1:2*odd;
        };
        return max(f(red,blue),f(blue,red));
    }
};
```

复杂度分析
* 时间复杂度：O(1)。
* 空间复杂度：O(1)。

# [第二题](https://leetcode.cn/problems/find-the-n-th-value-after-k-seconds/)

本题和周赛第三题是一样的，令 k=2 即可

# [第三题](https://leetcode.cn/problems/maximum-total-reward-using-operations-i/)  

前置知识：模运算的世界：当加减乘除遇上取模

考察等式

(a+b)modk=(b+c)modk
根据前置知识中的恒等式，移项得

(a+b−(b+c))modk=0
化简得

(a−c)modk=0
这意味着 a 与 c 关于模 k 同余。

根据该性质，有效子序列的奇数项都关于模 k 同余，偶数项都关于模 k 同余。

因此，如果把每个 nums[i] 都变成 nums[i]modk，那么原问题等价于：

寻找一个最长的子序列，满足子序列奇数项都相同，偶数项都相同。
方法一：考察子序列的最后两项
从左到右遍历 nums，遍历的同时，维护一个二维数组 f[y][x]，表示最后两项模 k 分别为 y 和 x 的子序列的长度。

对于 x=nums[i]modk，我们可以在「最后两项模 k 分别为 x 和 y 的子序列」的末尾添加 nums[i]，那么「最后两项模 k 分别为 y 和 x 的子序列」的长度会增加 1，即

f[y][x]=f[x][y]+1
最后答案为 f[i][j] 的最大值。

答疑
问：如何理解这个递推？它和记忆化搜索的区别是什么？

答：对比二者的计算顺序。如果用记忆化搜索来做，需要单独计算「最左（或者最右）两项模 k 分别为 x 和 y 的子序列」的长度，这是「单线程」，必须查找下一个元素的位置。而递推的计算顺序是，（假设我们先遍历到了元素 2，然后遍历到了元素 3）一会计算一下「最后两项模 k 分别为 y 和 2 的子序列」，一会又计算一下「最后两项模 k 分别为 y 和 3 的子序列」，这是「多线程」，没有查找元素位置的过程，遇到谁就处理谁。

```
class Solution {
public:
    int maximumLength(vector<int>& nums, int k) {
        int ans=0;
        vector<vector<int>>f(k,vector<int>(k));
        for(int x:nums){
            x%=k;
            for(int y=0;y<k;y++){
                f[y][x]=f[x][y]+1;
                ans=max(ans,f[y][x]);
            }
        }
        return ans;
    }
};
```

复杂度分析  
* 时间复杂度：O(k<sup>2</sup>+nk)。
* 空间复杂度：O(k<sup>2</sup>)。

方法二：枚举余数，考察子序列的最后一项
枚举子序列相邻两项模 k 的结果为 m=0,1,2,⋯,k−1。

如果知道了子序列的最后一项（假设是 x），那么子序列的倒数第二项也就确定了，即

(m−xmodk+k)modk
加 k 再模 k 是为了在 m<xmodk 时，保证计算结果非负。

类似方法一，从左到右遍历 nums 的同时，维护一个数组 f[x]，表示最后一项模 k 为 x 的子序列的长度。

对于 x=nums[i]modk，我们可以在「最后一项模 k 为 (m−xmodk+k)modk 的子序列」的末尾添加 nums[i]，那么「最后一项模 k 为 x 的子序列」的长度会增加 1，即

f[x]=f[(m−xmodk+k)modk]+1

```
class Solution {
public:
    int maximumLength(vector<int>& nums, int k) {
        int ans = 0;
        for (int m = 0; m < k; m++) {
            vector<int> f(k);
            for (int x : nums) {
                x %= k;
                f[x] = f[(m - x + k) % k] + 1;
                ans = max(ans, f[x]);
            }
        }
        return ans;
    }
};
```
复杂度分析  
* 时间复杂度：O(k<sup>2</sup>+nk)。
* 空间复杂度：O(k)。

# [第四题](https://leetcode.cn/problems/maximum-total-reward-using-operations-ii/)

```
class Solution {
public:
    int diameter(vector<vector<int>>& edges) {
        vector<vector<int>> g(edges.size() + 1);
        for (auto& e : edges) {
            int x = e[0], y = e[1];
            g[x].push_back(y);
            g[y].push_back(x);
        }

        int res = 0;
        auto dfs = [&](auto&& dfs, int x, int fa) -> int {
            int max_len = 0;
            for (auto y : g[x]) {
                if (y != fa) {
                    int sub_len = dfs(dfs, y, x) + 1;
                    res = max(res, max_len + sub_len);
                    max_len = max(max_len, sub_len);
                }
            }
            return max_len;
        };
        dfs(dfs, 0, -1);
        return res;
    }

    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {
        int d1 = diameter(edges1);
        int d2 = diameter(edges2);
        return max({d1, d2, (d1 + 1) / 2 + (d2 + 1) / 2 + 1});
    }
};
```

复杂度分析  
* 时间复杂度：O(nm/w)，其中n是rewardValues的长度，$`m=max⁡(rewardValues)`$，w=64或32。  
* 空间复杂度：O(n+m/w)。   

